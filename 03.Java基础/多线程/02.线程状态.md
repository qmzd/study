### 线程状态

  #### 线程的五大状态：
  
    1.创建状态：new Thread() 线程对象一旦创建就进入新生状态；
    
    2.就绪状态（等待状态）：当调用start()方法，线程立即进入就绪状态，但不意味着立即调度执行；当抢到线程锁的时候变为运行状态，否则一直等待；
    
    3.运行状态：拿到线程锁后进入运行状态，线程才真正执行代码块；
    
    4.阻塞状态：当调用sleep，wait 或同步锁定时，线程进入阻塞状态，就是代码不往下执行，阻塞状态解除后重新进入等待状态，等待cpu调度执行；
    
    5.死亡状态：线程中断或者结束，一旦进入死亡状态，就不能再次启动；

### 线程的控制方法

  #### 线程休眠（sleep）：
    
    1.sleep（时间）指定当前线程阻塞的毫秒数；
    
    2.sleep存在异常InterruptedException;
    
    3.sleep时间达到后线程进入等待状态；
    
    4.sleep 可以模拟网络延时，倒计时等；
    
    5.每一个对象都有一个锁，sleep不会释放锁；
    
  #### 线程礼让（yield）：
  
    1. 礼让线程，让当前正在执行的线程暂停，但不阻塞；
    
    2. 将线程从运行状态转为准备状态；
    
    3.让cpu重新调度，礼让不一定成功！看CPU心情；
    
  #### 线程合并（join）插队：
  
    1.调用某线程的该方法，将当前线程与该线程“合并”，即等待该线程结束，再恢复当前线程的运行；类似于“插队”；
    
  #### 线程状态（Thread.State）：
  
    线程处于以下状态之一：
    
    NEW ： 尚未启动的线程处于此状态；
    
    RUNNABLE：在JAVA虚拟机中执行的线程处于此状态；
    
    BLOCKED：被阻塞等待监视器锁定的线程处于此状态；
    
    WAITING：正在等待另一个线程执行特定动作的线程处于此状态；
    
    TIME WAITTING：正在等待另一个线程执行动作到达指定等待时间的线程处于此状态；
    
    TERMINATED：已退出的线程处于此状态；
    
  #### 线程优先级（setPriority）：
  
    1.设置线程优先级数值；Java提供了一个线程调度器来监控程序中启动后进入就绪状态的所有县城，县城调度器按照优先级决定应该调度哪个线程来执行；
    
    2.线程的优先级用数字表示，范围从1~10；
        
        Thread.MIN_PRIORITY = 1;
        
        Thread.MAX_PRIORITY = 10;
        
        Thread.NORM_PRIORITY = 5;
        
        线程优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看cpu的调度；
        
    3.使用一下方法改变或获取优先级  setPriority();  getPriority ();   
  
#### 守护线程（daemon）：

    1.线程分为用户线程和守护线程；
    
    2.虚拟机必须确保用户线程执行完毕；
    
    3.虚拟机不用等待守护线程执行完毕；
    
    4.守护线程比如后台记录操作日志，监控呢欧村，垃圾回收等待；
    
    
#### 线程同步：

    发生在多个线程操作同一个资源时（多线程）；
    
    解决方法：队列+锁； 由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时
    加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在一下问题：
    
    1. 一个线程持有锁会导致其他所有需要此锁的线程挂起；
    
    2. 在多线程竞争下，加锁，释放锁会导致比较多得上下文切换和调度延时，引起性能问题；
    
    3.如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题；
